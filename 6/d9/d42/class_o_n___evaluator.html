<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.8.13"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>openNURBS SDK Help: ON_Evaluator Class Reference</title>
  <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
  <!-- <script type="text/javascript" src="../../jquery.js"></script> -->
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script type="text/javascript" src="../../dynsections.js"></script>
  <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <!-- smartmenus -->
  <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
  <script type="text/javascript" src="../../jquery.smartmenus.js"></script>
  <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.js"></script>
</head>
<body>
  <!-- navbar -->
  <div class="navbar navbar-default navbar-static top" role="navigation">
    <div class="navbar-header">
      <a class="navbar-brand">openNURBS SDK Help 6.0</a>
    </div>
  </div>
  <div class="container">
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="page-content">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="../../de/db9/class_o_n___evaluator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_Evaluator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract function with an arbitrary number of parameters and values. <a class="el" href="../../d9/d42/class_o_n___evaluator.html" title="Abstract function with an arbitrary number of parameters and values. ON_Evaluator is used to pass fun...">ON_Evaluator</a> is used to pass functions to local solvers.  
 <a href="../../d9/d42/class_o_n___evaluator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d2/d00/opennurbs__math_8h_source.html">opennurbs_math.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade46238934de49cb6a91870f707381a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#ade46238934de49cb6a91870f707381a9">ON_Evaluator</a> (int parameter_count, int value_count, const <a class="el" href="../../dc/dc7/class_o_n___interval.html">ON_Interval</a> *domain, const bool *periodic)</td></tr>
<tr class="memdesc:ade46238934de49cb6a91870f707381a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of the class for a function that takes parameter_count input functions and returns value_count values. If the domain is infinite, pass a nullptr for the domain[] and periodic[] arrays. If the domain is finite, pass a domain[] array with parameter_count increasing intervals. If one or more of the parameters is periodic, pass the fundamental domain in the domain[] array and a true in the periodic[] array.  <a href="#ade46238934de49cb6a91870f707381a9">More...</a><br /></td></tr>
<tr class="separator:ade46238934de49cb6a91870f707381a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27f0a638112728273fde6156133d463"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#ae27f0a638112728273fde6156133d463">~ON_Evaluator</a> ()</td></tr>
<tr class="separator:ae27f0a638112728273fde6156133d463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b98b96b74c0d751357612989490ebb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dc7/class_o_n___interval.html">ON_Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a8b98b96b74c0d751357612989490ebb0">Domain</a> (int parameter_index) const</td></tr>
<tr class="memdesc:a8b98b96b74c0d751357612989490ebb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true.  <a href="#a8b98b96b74c0d751357612989490ebb0">More...</a><br /></td></tr>
<tr class="separator:a8b98b96b74c0d751357612989490ebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49026c63f638b1da01536622c6afc1bf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a49026c63f638b1da01536622c6afc1bf">Evaluate</a> (const double *parameters, double *values, double **jacobian)=0</td></tr>
<tr class="memdesc:a49026c63f638b1da01536622c6afc1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the function that takes m_parameter_count parameters and returns a m_value_count dimensional point.  <a href="#a49026c63f638b1da01536622c6afc1bf">More...</a><br /></td></tr>
<tr class="separator:a49026c63f638b1da01536622c6afc1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430ebc027c6d2e7c313844092de819c7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a430ebc027c6d2e7c313844092de819c7">EvaluateHessian</a> (const double *parameters, double *value, double *gradient, double **hessian)</td></tr>
<tr class="memdesc:a430ebc027c6d2e7c313844092de819c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTIONAL ability to evaluate the hessian in the case when m_value_count is one. If your function has more that one value or it is not feasable to evaluate the hessian, then do not override this function. The default implementation returns -1.  <a href="#a430ebc027c6d2e7c313844092de819c7">More...</a><br /></td></tr>
<tr class="separator:a430ebc027c6d2e7c313844092de819c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3f628b395c6c4d88d521e8751cc55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#ae9a3f628b395c6c4d88d521e8751cc55">FiniteDomain</a> () const</td></tr>
<tr class="memdesc:ae9a3f628b395c6c4d88d521e8751cc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions can have finite or infinite domains. Finite domains are specified by passing the domain[] array to the constructor or filling in the m_domain[] member variable. If m_domain.Count() == m_parameter_count &gt; 0, then the function has finite domains.  <a href="#ae9a3f628b395c6c4d88d521e8751cc55">More...</a><br /></td></tr>
<tr class="separator:ae9a3f628b395c6c4d88d521e8751cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27be468ed93adb95e90e12a051b25cd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a27be468ed93adb95e90e12a051b25cd4">Periodic</a> (int parameter_index) const</td></tr>
<tr class="memdesc:a27be468ed93adb95e90e12a051b25cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true.  <a href="#a27be468ed93adb95e90e12a051b25cd4">More...</a><br /></td></tr>
<tr class="separator:a27be468ed93adb95e90e12a051b25cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a39ab8c1ebc601902f5a2ff8a0d21c6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a39ab8c1ebc601902f5a2ff8a0d21c6e4">m_bPeriodicParameter</a></td></tr>
<tr class="separator:a39ab8c1ebc601902f5a2ff8a0d21c6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7e3d681c06c498b26529affd1d22f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="../../dc/dc7/class_o_n___interval.html">ON_Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a8e7e3d681c06c498b26529affd1d22f7">m_domain</a></td></tr>
<tr class="separator:a8e7e3d681c06c498b26529affd1d22f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8118ded2762c9e5f38be107e2a5d2d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a9d8118ded2762c9e5f38be107e2a5d2d">m_parameter_count</a></td></tr>
<tr class="separator:a9d8118ded2762c9e5f38be107e2a5d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61abf86c2c652d0ab38548f6eba4d482"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d42/class_o_n___evaluator.html#a61abf86c2c652d0ab38548f6eba4d482">m_value_count</a></td></tr>
<tr class="separator:a61abf86c2c652d0ab38548f6eba4d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract function with an arbitrary number of parameters and values. <a class="el" href="../../d9/d42/class_o_n___evaluator.html" title="Abstract function with an arbitrary number of parameters and values. ON_Evaluator is used to pass fun...">ON_Evaluator</a> is used to pass functions to local solvers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade46238934de49cb6a91870f707381a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade46238934de49cb6a91870f707381a9">&#9670;&nbsp;</a></span>ON_Evaluator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_Evaluator::ON_Evaluator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parameter_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/dc7/class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construction of the class for a function that takes parameter_count input functions and returns value_count values. If the domain is infinite, pass a nullptr for the domain[] and periodic[] arrays. If the domain is finite, pass a domain[] array with parameter_count increasing intervals. If one or more of the parameters is periodic, pass the fundamental domain in the domain[] array and a true in the periodic[] array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameter_count</td><td>[in] &gt;= 1. Number of input parameters</td></tr>
    <tr><td class="paramname">value_count</td><td>[in] &gt;= 1. Number of output values.</td></tr>
    <tr><td class="paramname">domain</td><td>[in] If not nullptr, then this is an array of parameter_count increasing intervals that defines the domain of the function.</td></tr>
    <tr><td class="paramname">periodic</td><td>[in] if not nullptr, then this is an array of parameter_count bools where b[i] is true if the i-th parameter is periodic. Valid increasing finite domains must be specificed when this parameter is not nullptr.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae27f0a638112728273fde6156133d463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27f0a638112728273fde6156133d463">&#9670;&nbsp;</a></span>~ON_Evaluator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ON_Evaluator::~ON_Evaluator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8b98b96b74c0d751357612989490ebb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b98b96b74c0d751357612989490ebb0">&#9670;&nbsp;</a></span>Domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dc7/class_o_n___interval.html">ON_Interval</a> ON_Evaluator::Domain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parameter_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. </p>
<dl class="section return"><dt>Returns</dt><dd>The domain of the parameter. If the domain is infinite, the (-1.0e300, +1.0e300) is returned. </dd></dl>

</div>
</div>
<a id="a49026c63f638b1da01536622c6afc1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49026c63f638b1da01536622c6afc1bf">&#9670;&nbsp;</a></span>Evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ON_Evaluator::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the function that takes m_parameter_count parameters and returns a m_value_count dimensional point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>[in] array of m_parameter_count evaluation parameters</td></tr>
    <tr><td class="paramname">values</td><td>[out] array of m_value_count function values</td></tr>
    <tr><td class="paramname">jacobian</td><td>[out] If nullptr, simply evaluate the value of the function. If not nullptr, this is the jacobian of the function. jacobian[i][j] = j-th partial of the i-th value 0 &lt;= i &lt; m_value_count, 0 &lt;= j &lt; m_parameter_count If not nullptr, then all the memory for the jacobian is allocated, you just need to fill in the answers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 = unable to evaluate 1 = successful evaluation 2 = found answer, terminate search </dd></dl>
<div class="fragment"><div class="line">If f(u,v) = square of the distance from a fixed point P to a</div><div class="line">surface evaluated at (u,v), then</div><div class="line">@verbatim</div><div class="line">    values[0] = (S-P)o(S-P)</div><div class="line">    jacobian[0] = ( 2*(Du o (S-P)), 2*(Dv o (S-P)) )</div><div class="line"><span class="keyword">@end</span>verbatim</div><div class="line"></div><div class="line">where S, Du, Dv = surface point and first partials evaluated</div><div class="line">at u=parameters[0], v = parameters[1].</div><div class="line"></div><div class="line">If the <span class="keyword">function</span> takes 3 parameters, say (x,y,z), and returns</div><div class="line">two values, say f(x,y,z) and g(z,y,z), then</div><div class="line">@verbatim</div><div class="line">    values[0] = f(x,y,z)</div><div class="line">    values[1] = g(x,y,z)</div><div class="line"></div><div class="line">    jacobian[0] = (DfDx, DfDy, DfDz)</div><div class="line">    jacobian[1] = (DgDx, DgDy, DgDz)</div><div class="line"><span class="keyword">@end</span>verbatim</div><div class="line"></div><div class="line">where dfx denotes the first partial of f with respect to x.</div></div><!-- fragment --> 
</div>
</div>
<a id="a430ebc027c6d2e7c313844092de819c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430ebc027c6d2e7c313844092de819c7">&#9670;&nbsp;</a></span>EvaluateHessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ON_Evaluator::EvaluateHessian </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>hessian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OPTIONAL ability to evaluate the hessian in the case when m_value_count is one. If your function has more that one value or it is not feasable to evaluate the hessian, then do not override this function. The default implementation returns -1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>[in] array of m_parameter_count evaluation parameters</td></tr>
    <tr><td class="paramname">value</td><td>[out] value of the function (one double)</td></tr>
    <tr><td class="paramname">gradient</td><td>[out] The gradient of the function. This is a vector of length m_parameter_count; gradient[i] is the first partial of the function with respect to the i-th parameter.</td></tr>
    <tr><td class="paramname">hessian</td><td>[out] The hessian of the function. This is an m_parameter_count x m_parameter_count symmetric matrix: hessian[i][j] is the second partial of the function with respect to the i-th and j-th parameters. The evaluator is responsible for filling in both the upper and lower triangles. Since the matrix is symmetrix, you should do something like evaluate the upper triangle and copy the values to the lower tiangle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 = Hessian evaluation not available. 0 = unable to evaluate 1 = successful evaluation 2 = found answer, terminate search </dd></dl>

</div>
</div>
<a id="ae9a3f628b395c6c4d88d521e8751cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3f628b395c6c4d88d521e8751cc55">&#9670;&nbsp;</a></span>FiniteDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Evaluator::FiniteDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions can have finite or infinite domains. Finite domains are specified by passing the domain[] array to the constructor or filling in the m_domain[] member variable. If m_domain.Count() == m_parameter_count &gt; 0, then the function has finite domains. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the domain of the function is finite. </dd></dl>

</div>
</div>
<a id="a27be468ed93adb95e90e12a051b25cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27be468ed93adb95e90e12a051b25cd4">&#9670;&nbsp;</a></span>Periodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Evaluator::Periodic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parameter_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the function parameter is periodic. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39ab8c1ebc601902f5a2ff8a0d21c6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ab8c1ebc601902f5a2ff8a0d21c6e4">&#9670;&nbsp;</a></span>m_bPeriodicParameter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt;bool&gt; ON_Evaluator::m_bPeriodicParameter</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e7e3d681c06c498b26529affd1d22f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7e3d681c06c498b26529affd1d22f7">&#9670;&nbsp;</a></span>m_domain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dfe/class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="../../dc/dc7/class_o_n___interval.html">ON_Interval</a>&gt; ON_Evaluator::m_domain</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d8118ded2762c9e5f38be107e2a5d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8118ded2762c9e5f38be107e2a5d2d">&#9670;&nbsp;</a></span>m_parameter_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ON_Evaluator::m_parameter_count</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61abf86c2c652d0ab38548f6eba4d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61abf86c2c652d0ab38548f6eba4d482">&#9670;&nbsp;</a></span>m_value_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ON_Evaluator::m_value_count</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
</div> <!-- page-content -->
</div> <!-- container -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 2 2018 07:57:29 for openNURBS SDK Help by <a href="http://www.doxygen.org/index.html">
<!-- <img class="footer" src="../../doxygen.png" alt="doxygen"/> -->
Doxygen
</a> 1.8.13
</small></address>
<script type="text/javascript" src="../../doxy-boot.js"></script>
</body>
</html>
