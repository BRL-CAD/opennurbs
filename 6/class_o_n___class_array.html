<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>openNURBS SDK Help: ON_ClassArray&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openNURBS SDK Help
   &#160;<span id="projectnumber">6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_o_n___class_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_ClassArray&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="opennurbs__array_8h_source.html">opennurbs_array.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_ClassArray&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_n___class_array.png" usemap="#ON_5FClassArray_3C_20T_20_3E_map" alt=""/>
  <map id="ON_5FClassArray_3C_20T_20_3E_map" name="ON_5FClassArray_3C_20T_20_3E_map">
<area href="class_o_n___object_array.html" alt="ON_ObjectArray&lt; T &gt;" shape="rect" coords="0,56,139,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa12a2a08c847c3221d9ebd037cd67236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aa12a2a08c847c3221d9ebd037cd67236">ON_ClassArray</a> () ON_NOEXCEPT</td></tr>
<tr class="memdesc:aa12a2a08c847c3221d9ebd037cd67236"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction ////////////////////////////////////////////////////////  <a href="#aa12a2a08c847c3221d9ebd037cd67236">More...</a><br /></td></tr>
<tr class="separator:aa12a2a08c847c3221d9ebd037cd67236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29bdce0835c65c43d220d2bb3d18c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a2a29bdce0835c65c43d220d2bb3d18c7">ON_ClassArray</a> (size_t)</td></tr>
<tr class="memdesc:a2a29bdce0835c65c43d220d2bb3d18c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">size_t parameter = initial capacity  <a href="#a2a29bdce0835c65c43d220d2bb3d18c7">More...</a><br /></td></tr>
<tr class="separator:a2a29bdce0835c65c43d220d2bb3d18c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a6a9e85b363987aede2c91e46b5036"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aa0a6a9e85b363987aede2c91e46b5036">ON_ClassArray</a> (const <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:aa0a6a9e85b363987aede2c91e46b5036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aa0a6a9e85b363987aede2c91e46b5036">More...</a><br /></td></tr>
<tr class="separator:aa0a6a9e85b363987aede2c91e46b5036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8afae29c14a95b85324992907c38929"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ad8afae29c14a95b85324992907c38929">~ON_ClassArray</a> ()</td></tr>
<tr class="memdesc:ad8afae29c14a95b85324992907c38929"><td class="mdescLeft">&#160;</td><td class="mdescRight">override for struct member deallocation, etc.  <a href="#ad8afae29c14a95b85324992907c38929">More...</a><br /></td></tr>
<tr class="separator:ad8afae29c14a95b85324992907c38929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417093e16515cefacd17dc940ea4a52f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a417093e16515cefacd17dc940ea4a52f">Append</a> (const T &amp;)</td></tr>
<tr class="separator:a417093e16515cefacd17dc940ea4a52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad863aa00c481c6d22cf0bab4d9fab0b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ad863aa00c481c6d22cf0bab4d9fab0b7">Append</a> (int, const T *)</td></tr>
<tr class="memdesc:ad863aa00c481c6d22cf0bab4d9fab0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append copy of an array T[count].  <a href="#ad863aa00c481c6d22cf0bab4d9fab0b7">More...</a><br /></td></tr>
<tr class="separator:ad863aa00c481c6d22cf0bab4d9fab0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3453ebec06da96dd2bc10f66b4312dda"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a3453ebec06da96dd2bc10f66b4312dda">AppendNew</a> ()</td></tr>
<tr class="memdesc:a3453ebec06da96dd2bc10f66b4312dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">array operations ////////////////////////////////////////////////////  <a href="#a3453ebec06da96dd2bc10f66b4312dda">More...</a><br /></td></tr>
<tr class="separator:a3453ebec06da96dd2bc10f66b4312dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36597e8827a812df0d9c6c81c1db4e81"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a36597e8827a812df0d9c6c81c1db4e81">Array</a> ()</td></tr>
<tr class="memdesc:a36597e8827a812df0d9c6c81c1db4e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_o_n___class_array.html#a36597e8827a812df0d9c6c81c1db4e81" title="The Array() function return the. ">Array()</a> function return the.  <a href="#a36597e8827a812df0d9c6c81c1db4e81">More...</a><br /></td></tr>
<tr class="separator:a36597e8827a812df0d9c6c81c1db4e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4772c4d3558d1d2567310010fa3add1d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a4772c4d3558d1d2567310010fa3add1d">Array</a> () const</td></tr>
<tr class="memdesc:a4772c4d3558d1d2567310010fa3add1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_a pointer value.  <a href="#a4772c4d3558d1d2567310010fa3add1d">More...</a><br /></td></tr>
<tr class="separator:a4772c4d3558d1d2567310010fa3add1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5451b98ba3fb0936ffbfe9f59cb4b09e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a5451b98ba3fb0936ffbfe9f59cb4b09e">At</a> (int)</td></tr>
<tr class="memdesc:a5451b98ba3fb0936ffbfe9f59cb4b09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">At(index) returns nullptr if index &lt; 0 or index &gt;= count.  <a href="#a5451b98ba3fb0936ffbfe9f59cb4b09e">More...</a><br /></td></tr>
<tr class="separator:a5451b98ba3fb0936ffbfe9f59cb4b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffadd4ef6e89cd8a7834d7baa83104c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aaffadd4ef6e89cd8a7834d7baa83104c">At</a> (unsigned int)</td></tr>
<tr class="separator:aaffadd4ef6e89cd8a7834d7baa83104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbfab010d82d1cea6155b6cf49a72d1"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a2bbfab010d82d1cea6155b6cf49a72d1">At</a> (ON__INT64)</td></tr>
<tr class="separator:a2bbfab010d82d1cea6155b6cf49a72d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d1c926554aad1bc07de202572d88f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a3a8d1c926554aad1bc07de202572d88f">At</a> (ON__UINT64)</td></tr>
<tr class="separator:a3a8d1c926554aad1bc07de202572d88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2928f1f8fbc5c101e3250fe8ba5ac2c5"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a2928f1f8fbc5c101e3250fe8ba5ac2c5">At</a> (int) const</td></tr>
<tr class="separator:a2928f1f8fbc5c101e3250fe8ba5ac2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedfef6fa79539b7de0be949c31cdee6"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aaedfef6fa79539b7de0be949c31cdee6">At</a> (unsigned int) const</td></tr>
<tr class="separator:aaedfef6fa79539b7de0be949c31cdee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af163db1328a3ff14d6eae781bb872dc4"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#af163db1328a3ff14d6eae781bb872dc4">At</a> (ON__INT64) const</td></tr>
<tr class="separator:af163db1328a3ff14d6eae781bb872dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1621f585217b42abd35061dabb7dfe2"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ac1621f585217b42abd35061dabb7dfe2">At</a> (ON__UINT64) const</td></tr>
<tr class="separator:ac1621f585217b42abd35061dabb7dfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f69264bb06391c81571f0182fbaef08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a6f69264bb06391c81571f0182fbaef08">BinarySearch</a> (const T *, int(*)(const T *, const T *)) const</td></tr>
<tr class="memdesc:a6f69264bb06391c81571f0182fbaef08"><td class="mdescLeft">&#160;</td><td class="mdescRight">See Also: ON_CompareIncreasing&lt;T&gt; and ON_CompareDeccreasing&lt;T&gt;  <a href="#a6f69264bb06391c81571f0182fbaef08">More...</a><br /></td></tr>
<tr class="separator:a6f69264bb06391c81571f0182fbaef08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70b91b3b3fd7ecfb8f8fcf3e1d342b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#af70b91b3b3fd7ecfb8f8fcf3e1d342b8">BinarySearch</a> (const T *, int(*)(const T *, const T *), int) const</td></tr>
<tr class="separator:af70b91b3b3fd7ecfb8f8fcf3e1d342b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af828eb3eedaefe303676b81b0b5bd0cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#af828eb3eedaefe303676b81b0b5bd0cd">Capacity</a> () const</td></tr>
<tr class="memdesc:af828eb3eedaefe303676b81b0b5bd0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">capacity of array  <a href="#af828eb3eedaefe303676b81b0b5bd0cd">More...</a><br /></td></tr>
<tr class="separator:af828eb3eedaefe303676b81b0b5bd0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1845abffe10408c4ce46046d9232f8e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8">Count</a> () const</td></tr>
<tr class="memdesc:a1845abffe10408c4ce46046d9232f8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">query ///////////////////////////////////////////////////////////////  <a href="#a1845abffe10408c4ce46046d9232f8e8">More...</a><br /></td></tr>
<tr class="separator:a1845abffe10408c4ce46046d9232f8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a86fe207a6b43c493104e166003250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ab8a86fe207a6b43c493104e166003250">Destroy</a> ()</td></tr>
<tr class="memdesc:ab8a86fe207a6b43c493104e166003250"><td class="mdescLeft">&#160;</td><td class="mdescRight">onfree any memory and set count and capacity to zero  <a href="#ab8a86fe207a6b43c493104e166003250">More...</a><br /></td></tr>
<tr class="separator:ab8a86fe207a6b43c493104e166003250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe0869a166cd4e3d74e5aaa731ab831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aebe0869a166cd4e3d74e5aaa731ab831">EmergencyDestroy</a> (void)</td></tr>
<tr class="memdesc:aebe0869a166cd4e3d74e5aaa731ab831"><td class="mdescLeft">&#160;</td><td class="mdescRight">emergency bailout ///////////////////////////////////////////////////  <a href="#aebe0869a166cd4e3d74e5aaa731ab831">More...</a><br /></td></tr>
<tr class="separator:aebe0869a166cd4e3d74e5aaa731ab831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc29b3806f214bf0253499255e307856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#acc29b3806f214bf0253499255e307856">Empty</a> ()</td></tr>
<tr class="memdesc:acc29b3806f214bf0253499255e307856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets count to 0, leaves capacity untouched.  <a href="#acc29b3806f214bf0253499255e307856">More...</a><br /></td></tr>
<tr class="separator:acc29b3806f214bf0253499255e307856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c04a9b48b53459764dffe506b5e34c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a00c04a9b48b53459764dffe506b5e34c">First</a> ()</td></tr>
<tr class="separator:a00c04a9b48b53459764dffe506b5e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9069a7bc0b5126ff143f70aa43b43230"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a9069a7bc0b5126ff143f70aa43b43230">First</a> () const</td></tr>
<tr class="memdesc:a9069a7bc0b5126ff143f70aa43b43230"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns nullptr if count = 0  <a href="#a9069a7bc0b5126ff143f70aa43b43230">More...</a><br /></td></tr>
<tr class="separator:a9069a7bc0b5126ff143f70aa43b43230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacff55bc065868229f3269bb47d0e31"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aeacff55bc065868229f3269bb47d0e31">HeapSort</a> (int(*)(const T *, const T *))</td></tr>
<tr class="memdesc:aeacff55bc065868229f3269bb47d0e31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___class_array.html#aaaccc2915ed9407ed77e5355ed02f61a" title="Sorts the array using the heap sort algorithm. ">QuickSort()</a> is generally the better choice.  <a href="#aeacff55bc065868229f3269bb47d0e31">More...</a><br /></td></tr>
<tr class="separator:aeacff55bc065868229f3269bb47d0e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebeebfb862065c0d62c00389ae3f499b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aebeebfb862065c0d62c00389ae3f499b">Insert</a> (int, const T &amp;)</td></tr>
<tr class="memdesc:aebeebfb862065c0d62c00389ae3f499b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert called with a reference uses operator =.  <a href="#aebeebfb862065c0d62c00389ae3f499b">More...</a><br /></td></tr>
<tr class="separator:aebeebfb862065c0d62c00389ae3f499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ea996fc990ee251d88b324bc8b08f2"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ac8ea996fc990ee251d88b324bc8b08f2">KeepArray</a> ()</td></tr>
<tr class="separator:ac8ea996fc990ee251d88b324bc8b08f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9dfdb1601fb20ce86dfe8244719665"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a5e9dfdb1601fb20ce86dfe8244719665">Last</a> ()</td></tr>
<tr class="separator:a5e9dfdb1601fb20ce86dfe8244719665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558bc5d60a7dc8d9885a387e12bd8ae6"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a558bc5d60a7dc8d9885a387e12bd8ae6">Last</a> () const</td></tr>
<tr class="memdesc:a558bc5d60a7dc8d9885a387e12bd8ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns nullptr if count = 0  <a href="#a558bc5d60a7dc8d9885a387e12bd8ae6">More...</a><br /></td></tr>
<tr class="separator:a558bc5d60a7dc8d9885a387e12bd8ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b36908b477ca9e79dd435d1802237a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a39b36908b477ca9e79dd435d1802237a">NewCapacity</a> () const</td></tr>
<tr class="separator:a39b36908b477ca9e79dd435d1802237a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42aed50f4d66e4a33379db171c71fd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ad42aed50f4d66e4a33379db171c71fd8">operator const T *</a> () const</td></tr>
<tr class="separator:ad42aed50f4d66e4a33379db171c71fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8b150fdfb6f1c2d5a625ee09273432"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a5e8b150fdfb6f1c2d5a625ee09273432">operator T*</a> ()</td></tr>
<tr class="memdesc:a5e8b150fdfb6f1c2d5a625ee09273432"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cast operators return a pointer.  <a href="#a5e8b150fdfb6f1c2d5a625ee09273432">More...</a><br /></td></tr>
<tr class="separator:a5e8b150fdfb6f1c2d5a625ee09273432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b741c3481b50b44d69bd4a620296e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ab7b741c3481b50b44d69bd4a620296e8">operator=</a> (const <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:ab7b741c3481b50b44d69bd4a620296e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ab7b741c3481b50b44d69bd4a620296e8">More...</a><br /></td></tr>
<tr class="separator:ab7b741c3481b50b44d69bd4a620296e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e43c5172b763b79df57f2ebc6bc43e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a66e43c5172b763b79df57f2ebc6bc43e">operator[]</a> (int)</td></tr>
<tr class="separator:a66e43c5172b763b79df57f2ebc6bc43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a1f61c17d3a863abe8acc4b053bf9e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a38a1f61c17d3a863abe8acc4b053bf9e">operator[]</a> (unsigned int)</td></tr>
<tr class="separator:a38a1f61c17d3a863abe8acc4b053bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd3c038ace9e6b518f66a87cce6d496"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#afcd3c038ace9e6b518f66a87cce6d496">operator[]</a> (ON__INT64)</td></tr>
<tr class="separator:afcd3c038ace9e6b518f66a87cce6d496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015a992fe8121363317327c107c75c2d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a015a992fe8121363317327c107c75c2d">operator[]</a> (ON__UINT64)</td></tr>
<tr class="separator:a015a992fe8121363317327c107c75c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4d1684feca2845464635d1c43b83a1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a6e4d1684feca2845464635d1c43b83a1">operator[]</a> (int) const</td></tr>
<tr class="separator:a6e4d1684feca2845464635d1c43b83a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f92b97d51e9aeb89e6c179a0fdd3fd"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ad5f92b97d51e9aeb89e6c179a0fdd3fd">operator[]</a> (unsigned int) const</td></tr>
<tr class="separator:ad5f92b97d51e9aeb89e6c179a0fdd3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae5677ba6120233a127eed7c9f564a1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a7ae5677ba6120233a127eed7c9f564a1">operator[]</a> (ON__INT64) const</td></tr>
<tr class="separator:a7ae5677ba6120233a127eed7c9f564a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33045d46c4aeaa089909a8eb3f0af3c"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ac33045d46c4aeaa089909a8eb3f0af3c">operator[]</a> (ON__UINT64) const</td></tr>
<tr class="separator:ac33045d46c4aeaa089909a8eb3f0af3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd469fb4742e6424f9cabb1c8787c2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a5cd469fb4742e6424f9cabb1c8787c2a">Permute</a> (const int *)</td></tr>
<tr class="separator:a5cd469fb4742e6424f9cabb1c8787c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaccc2915ed9407ed77e5355ed02f61a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aaaccc2915ed9407ed77e5355ed02f61a">QuickSort</a> (int(*)(const T *, const T *))</td></tr>
<tr class="memdesc:aaaccc2915ed9407ed77e5355ed02f61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the array using the heap sort algorithm.  <a href="#aaaccc2915ed9407ed77e5355ed02f61a">More...</a><br /></td></tr>
<tr class="separator:aaaccc2915ed9407ed77e5355ed02f61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6146b9447dfc2420fd1ddc79f4e25d13"><td class="memItemLeft" align="right" valign="top">virtual T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a6146b9447dfc2420fd1ddc79f4e25d13">Realloc</a> (T *, int)</td></tr>
<tr class="memdesc:a6146b9447dfc2420fd1ddc79f4e25d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">low level memory managment ///////////////////////////////////////  <a href="#a6146b9447dfc2420fd1ddc79f4e25d13">More...</a><br /></td></tr>
<tr class="separator:a6146b9447dfc2420fd1ddc79f4e25d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8613b7ab26dfabe4d630052a7167445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ac8613b7ab26dfabe4d630052a7167445">Remove</a> ()</td></tr>
<tr class="separator:ac8613b7ab26dfabe4d630052a7167445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91061614b1ec05b07b891579e83ed9a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a91061614b1ec05b07b891579e83ed9a8">Remove</a> (int)</td></tr>
<tr class="separator:a91061614b1ec05b07b891579e83ed9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619516bde2761154d967c96ee6c2b044"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a619516bde2761154d967c96ee6c2b044">Reserve</a> (size_t)</td></tr>
<tr class="memdesc:a619516bde2761154d967c96ee6c2b044"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory managment /////////////////////////////////////////////////  <a href="#a619516bde2761154d967c96ee6c2b044">More...</a><br /></td></tr>
<tr class="separator:a619516bde2761154d967c96ee6c2b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cf9e8ff629067820b78bf8fa4723fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ae0cf9e8ff629067820b78bf8fa4723fd">Reverse</a> ()</td></tr>
<tr class="memdesc:ae0cf9e8ff629067820b78bf8fa4723fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverse order  <a href="#ae0cf9e8ff629067820b78bf8fa4723fd">More...</a><br /></td></tr>
<tr class="separator:ae0cf9e8ff629067820b78bf8fa4723fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815f500f614c1742ba1f250b6e46ab1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a815f500f614c1742ba1f250b6e46ab1c">Search</a> (const T *, int(*)(const T *, const T *)) const</td></tr>
<tr class="separator:a815f500f614c1742ba1f250b6e46ab1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404695bf0683f18b0e2a1b2cc2538fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a404695bf0683f18b0e2a1b2cc2538fa3">SetArray</a> (T *)</td></tr>
<tr class="separator:a404695bf0683f18b0e2a1b2cc2538fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382c44cb8eaa73cc598d587fdfda5220"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a382c44cb8eaa73cc598d587fdfda5220">SetArray</a> (T *, int, int)</td></tr>
<tr class="separator:a382c44cb8eaa73cc598d587fdfda5220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bc44bb095af6dd8173a91441b78bfd"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a49bc44bb095af6dd8173a91441b78bfd">SetCapacity</a> (size_t)</td></tr>
<tr class="separator:a49bc44bb095af6dd8173a91441b78bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffd376de3d1af10f22caea8e5b5d114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a7ffd376de3d1af10f22caea8e5b5d114">SetCount</a> (int)</td></tr>
<tr class="memdesc:a7ffd376de3d1af10f22caea8e5b5d114"><td class="mdescLeft">&#160;</td><td class="mdescRight">low level memory managment //////////////////////////////////////////  <a href="#a7ffd376de3d1af10f22caea8e5b5d114">More...</a><br /></td></tr>
<tr class="separator:a7ffd376de3d1af10f22caea8e5b5d114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c5ba8cd96d26d1880e2ecd0f21b6e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a34c5ba8cd96d26d1880e2ecd0f21b6e5">Shrink</a> ()</td></tr>
<tr class="memdesc:a34c5ba8cd96d26d1880e2ecd0f21b6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove unused capacity  <a href="#a34c5ba8cd96d26d1880e2ecd0f21b6e5">More...</a><br /></td></tr>
<tr class="separator:a34c5ba8cd96d26d1880e2ecd0f21b6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317aa7fa09844d153876fa707ae87e2d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a317aa7fa09844d153876fa707ae87e2d">SizeOfArray</a> () const</td></tr>
<tr class="memdesc:a317aa7fa09844d153876fa707ae87e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">amount of memory in the m_a[] array  <a href="#a317aa7fa09844d153876fa707ae87e2d">More...</a><br /></td></tr>
<tr class="separator:a317aa7fa09844d153876fa707ae87e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0b64e2722e1e77fa1dfd5fe1e222de"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#adf0b64e2722e1e77fa1dfd5fe1e222de">SizeOfElement</a> () const</td></tr>
<tr class="memdesc:adf0b64e2722e1e77fa1dfd5fe1e222de"><td class="mdescLeft">&#160;</td><td class="mdescRight">amount of memory in an m_a[] array element  <a href="#adf0b64e2722e1e77fa1dfd5fe1e222de">More...</a><br /></td></tr>
<tr class="separator:adf0b64e2722e1e77fa1dfd5fe1e222de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc32ae1ba071b666ae49a9d2c2a041e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#acc32ae1ba071b666ae49a9d2c2a041e7">Sort</a> (ON::sort_algorithm sort_algorithm, int *, int(*)(const T *, const T *)) const</td></tr>
<tr class="separator:acc32ae1ba071b666ae49a9d2c2a041e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62165890958430bf2e377aaabc7fd93c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a62165890958430bf2e377aaabc7fd93c">Sort</a> (ON::sort_algorithm sort_algorithm, int *, int(*)(const T *, const T *, void *), void *) const</td></tr>
<tr class="separator:a62165890958430bf2e377aaabc7fd93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00c91a632d42ebbd4a04715750953ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#aa00c91a632d42ebbd4a04715750953ca">Swap</a> (int, int)</td></tr>
<tr class="memdesc:aa00c91a632d42ebbd4a04715750953ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap elements i and j  <a href="#aa00c91a632d42ebbd4a04715750953ca">More...</a><br /></td></tr>
<tr class="separator:aa00c91a632d42ebbd4a04715750953ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d1db4495becbc776ba36549ad93fd1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a64d1db4495becbc776ba36549ad93fd1">UnsignedCount</a> () const</td></tr>
<tr class="separator:a64d1db4495becbc776ba36549ad93fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e749c63bb84c2b09ade86283f6d7707"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a4e749c63bb84c2b09ade86283f6d7707">Zero</a> ()</td></tr>
<tr class="separator:a4e749c63bb84c2b09ade86283f6d7707"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a827238e8843d73fc952018a49278b4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a827238e8843d73fc952018a49278b4c6">ConstructDefaultElement</a> (T *)</td></tr>
<tr class="separator:a827238e8843d73fc952018a49278b4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4650327b91304e934de5bf6fe4bb9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#ad4650327b91304e934de5bf6fe4bb9ae">DestroyElement</a> (T &amp;)</td></tr>
<tr class="separator:ad4650327b91304e934de5bf6fe4bb9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58673a8f943b627698b7f917b8bbcfdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a58673a8f943b627698b7f917b8bbcfdf">Move</a> (int, int, int)</td></tr>
<tr class="memdesc:a58673a8f943b627698b7f917b8bbcfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">implimentation //////////////////////////////////////////////////////  <a href="#a58673a8f943b627698b7f917b8bbcfdf">More...</a><br /></td></tr>
<tr class="separator:a58673a8f943b627698b7f917b8bbcfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adfced275ab81f79ae6a60d5f660c0fdf"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#adfced275ab81f79ae6a60d5f660c0fdf">m_a</a></td></tr>
<tr class="memdesc:adfced275ab81f79ae6a60d5f660c0fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to array memory  <a href="#adfced275ab81f79ae6a60d5f660c0fdf">More...</a><br /></td></tr>
<tr class="separator:adfced275ab81f79ae6a60d5f660c0fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867ba84ffce9dc8146dc5e7ce71d9ac8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#a867ba84ffce9dc8146dc5e7ce71d9ac8">m_capacity</a></td></tr>
<tr class="memdesc:a867ba84ffce9dc8146dc5e7ce71d9ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">actual length of m_a[]  <a href="#a867ba84ffce9dc8146dc5e7ce71d9ac8">More...</a><br /></td></tr>
<tr class="separator:a867ba84ffce9dc8146dc5e7ce71d9ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af361d7cf1705dccf62a534ddd0c48a69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___class_array.html#af361d7cf1705dccf62a534ddd0c48a69">m_count</a></td></tr>
<tr class="memdesc:af361d7cf1705dccf62a534ddd0c48a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">0 &lt;= m_count &lt;= m_capacity  <a href="#af361d7cf1705dccf62a534ddd0c48a69">More...</a><br /></td></tr>
<tr class="separator:af361d7cf1705dccf62a534ddd0c48a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class ON_ClassArray&lt; T &gt;</h3>

<p>The ON_ClassArray&lt;&gt; template is designed to be used with classes that require non-trivial construction or destruction. Any class used with the ON_ClassArray&lt;&gt; template must have a robust <a class="el" href="class_o_n___class_array.html#ab7b741c3481b50b44d69bd4a620296e8" title="Assignment operator. ">operator=()</a>.</p>
<p>By default, ON_ClassArray&lt;&gt; uses onrealloc() to manage the dynamic array memory. If you want to use something besides onrealloc() to manage the array memory, then override <a class="el" href="class_o_n___class_array.html#a6146b9447dfc2420fd1ddc79f4e25d13" title="low level memory managment /////////////////////////////////////// ">ON_ClassArray::Realloc()</a>. In practice this means that if your class has members with back-pointers, then you cannot use it in the defaule <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>. See <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a> for an example. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa12a2a08c847c3221d9ebd037cd67236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12a2a08c847c3221d9ebd037cd67236">&#9670;&nbsp;</a></span>ON_ClassArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construction //////////////////////////////////////////////////////// </p>

</div>
</div>
<a id="a2a29bdce0835c65c43d220d2bb3d18c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a29bdce0835c65c43d220d2bb3d18c7">&#9670;&nbsp;</a></span>ON_ClassArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size_t parameter = initial capacity </p>

</div>
</div>
<a id="aa0a6a9e85b363987aede2c91e46b5036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a6a9e85b363987aede2c91e46b5036">&#9670;&nbsp;</a></span>ON_ClassArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>&lt; operator= defined below </p>

</div>
</div>
<a id="ad8afae29c14a95b85324992907c38929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8afae29c14a95b85324992907c38929">&#9670;&nbsp;</a></span>~ON_ClassArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::~<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>override for struct member deallocation, etc. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a417093e16515cefacd17dc940ea4a52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417093e16515cefacd17dc940ea4a52f">&#9670;&nbsp;</a></span>Append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append copy of element. Increments count by 1. </p>
<p>&lt; (int) cast is for 64 bit pointers</p>
<p>26 Sep 2005 Dale Lear User passed in an element of the m_a[] that will get reallocated by the call to Reserve(newcapacity). <br />
<br />
 &lt; ON_*Array&lt;&gt; templates do not require robust copy constructor.</p>
<p>&lt; ON_*Array&lt;&gt; templates require a robust operator=. </p>

</div>
</div>
<a id="ad863aa00c481c6d22cf0bab4d9fab0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad863aa00c481c6d22cf0bab4d9fab0b7">&#9670;&nbsp;</a></span>Append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append copy of an array T[count]. </p>

</div>
</div>
<a id="a3453ebec06da96dd2bc10f66b4312dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3453ebec06da96dd2bc10f66b4312dda">&#9670;&nbsp;</a></span>AppendNew()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::AppendNew </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>array operations //////////////////////////////////////////////////// </p>
<p>Most efficient way to add a new class to the array. Increases count by 1. </p>
<p>First destroy what's there ..</p>
<p>and then get a properly initialized element </p>

</div>
</div>
<a id="a36597e8827a812df0d9c6c81c1db4e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36597e8827a812df0d9c6c81c1db4e81">&#9670;&nbsp;</a></span>Array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="class_o_n___class_array.html#a36597e8827a812df0d9c6c81c1db4e81" title="The Array() function return the. ">Array()</a> function return the. </p>

</div>
</div>
<a id="a4772c4d3558d1d2567310010fa3add1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4772c4d3558d1d2567310010fa3add1d">&#9670;&nbsp;</a></span>Array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>m_a pointer value. </p>

</div>
</div>
<a id="a5451b98ba3fb0936ffbfe9f59cb4b09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5451b98ba3fb0936ffbfe9f59cb4b09e">&#9670;&nbsp;</a></span>At() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>At(index) returns nullptr if index &lt; 0 or index &gt;= count. </p>

</div>
</div>
<a id="aaffadd4ef6e89cd8a7834d7baa83104c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffadd4ef6e89cd8a7834d7baa83104c">&#9670;&nbsp;</a></span>At() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bbfab010d82d1cea6155b6cf49a72d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbfab010d82d1cea6155b6cf49a72d1">&#9670;&nbsp;</a></span>At() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">ON__INT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a8d1c926554aad1bc07de202572d88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8d1c926554aad1bc07de202572d88f">&#9670;&nbsp;</a></span>At() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">ON__UINT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2928f1f8fbc5c101e3250fe8ba5ac2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2928f1f8fbc5c101e3250fe8ba5ac2c5">&#9670;&nbsp;</a></span>At() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaedfef6fa79539b7de0be949c31cdee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaedfef6fa79539b7de0be949c31cdee6">&#9670;&nbsp;</a></span>At() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af163db1328a3ff14d6eae781bb872dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af163db1328a3ff14d6eae781bb872dc4">&#9670;&nbsp;</a></span>At() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">ON__INT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1621f585217b42abd35061dabb7dfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1621f585217b42abd35061dabb7dfe2">&#9670;&nbsp;</a></span>At() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::At </td>
          <td>(</td>
          <td class="paramtype">ON__UINT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f69264bb06391c81571f0182fbaef08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f69264bb06391c81571f0182fbaef08">&#9670;&nbsp;</a></span>BinarySearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::BinarySearch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const T *, const T *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See Also: ON_CompareIncreasing&lt;T&gt; and ON_CompareDeccreasing&lt;T&gt; </p>
<p>BinarySearch( p, compare ) does a fast search of a sorted array and returns the smallest index "i" of the element that satisifies 0==compare(p,&amp;array[i]).</p>
<p>BinarySearch( p, compare, count ) does a fast search of the first count element sorted array and returns the smallest index "i" of the element that satisifies 0==compare(p,&amp;array[i]). The version that takes a "count" is useful when elements are being appended during a calculation and the appended elements are not sorted.</p>
<p>If the search is successful, <a class="el" href="class_o_n___class_array.html#a6f69264bb06391c81571f0182fbaef08" title="See Also: ON_CompareIncreasing&lt;T&gt; and ON_CompareDeccreasing&lt;T&gt; ">BinarySearch()</a> returns the index of the element (&gt;=0). If the search is not successful, <a class="el" href="class_o_n___class_array.html#a6f69264bb06391c81571f0182fbaef08" title="See Also: ON_CompareIncreasing&lt;T&gt; and ON_CompareDeccreasing&lt;T&gt; ">BinarySearch()</a> returns -1. Use QuickSort( compare ) or, in rare cases and after meaningful performance testing using optimzed release builds, HeapSort( compare ) to sort the array. </p>

</div>
</div>
<a id="af70b91b3b3fd7ecfb8f8fcf3e1d342b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70b91b3b3fd7ecfb8f8fcf3e1d342b8">&#9670;&nbsp;</a></span>BinarySearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::BinarySearch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const T *, const T *)&#160;</td>
          <td class="paramname"><em>compar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af828eb3eedaefe303676b81b0b5bd0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af828eb3eedaefe303676b81b0b5bd0cd">&#9670;&nbsp;</a></span>Capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>capacity of array </p>

</div>
</div>
<a id="a827238e8843d73fc952018a49278b4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827238e8843d73fc952018a49278b4c6">&#9670;&nbsp;</a></span>ConstructDefaultElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::ConstructDefaultElement </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>use placement ( new(size_t,void*) ) to construct T in supplied memory </p>

</div>
</div>
<a id="a1845abffe10408c4ce46046d9232f8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1845abffe10408c4ce46046d9232f8e8">&#9670;&nbsp;</a></span>Count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query /////////////////////////////////////////////////////////////// </p>
<p>number of elements in array </p>

</div>
</div>
<a id="ab8a86fe207a6b43c493104e166003250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a86fe207a6b43c493104e166003250">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>onfree any memory and set count and capacity to zero </p>

</div>
</div>
<a id="ad4650327b91304e934de5bf6fe4bb9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4650327b91304e934de5bf6fe4bb9ae">&#9670;&nbsp;</a></span>DestroyElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::DestroyElement </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebe0869a166cd4e3d74e5aaa731ab831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe0869a166cd4e3d74e5aaa731ab831">&#9670;&nbsp;</a></span>EmergencyDestroy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::EmergencyDestroy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>emergency bailout /////////////////////////////////////////////////// </p>
<p>emergency destroy ///////////////////////////////////////////////////</p>
<p>call only when memory used by this array may have become invalid for reasons beyond your control. <a class="el" href="class_o_n___class_array.html#aebe0869a166cd4e3d74e5aaa731ab831" title="emergency bailout /////////////////////////////////////////////////// ">EmergencyDestroy()</a> zeros anything that could possibly cause <a class="el" href="class_o_n___class_array.html#ad8afae29c14a95b85324992907c38929" title="override for struct member deallocation, etc. ">~ON_ClassArray()</a> to crash. </p>

</div>
</div>
<a id="acc29b3806f214bf0253499255e307856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc29b3806f214bf0253499255e307856">&#9670;&nbsp;</a></span>Empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets count to 0, leaves capacity untouched. </p>
<p>This call to memset is ok even when T has a vtable because in-place construction is used later. </p>

</div>
</div>
<a id="a00c04a9b48b53459764dffe506b5e34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c04a9b48b53459764dffe506b5e34c">&#9670;&nbsp;</a></span>First() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::First </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9069a7bc0b5126ff143f70aa43b43230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9069a7bc0b5126ff143f70aa43b43230">&#9670;&nbsp;</a></span>First() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::First </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns nullptr if count = 0 </p>

</div>
</div>
<a id="aeacff55bc065868229f3269bb47d0e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacff55bc065868229f3269bb47d0e31">&#9670;&nbsp;</a></span>HeapSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::HeapSort </td>
          <td>(</td>
          <td class="paramtype">int(*)(const T *, const T *)&#160;</td>
          <td class="paramname"><em>compar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___class_array.html#aaaccc2915ed9407ed77e5355ed02f61a" title="Sorts the array using the heap sort algorithm. ">QuickSort()</a> is generally the better choice. </p>
<p>Sorts the array using the heap sort algorithm. See Also: ON_CompareIncreasing&lt;T&gt; and ON_CompareDeccreasing&lt;T&gt; </p>

<p>Reimplemented in <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; T &gt;</a>, <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_Texture &gt;</a>, <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_BrepTrim &gt;</a>, <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_BrepFaceSide &gt;</a>, <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_BrepEdge &gt;</a>, <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_BrepLoop &gt;</a>, <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_BrepRegion &gt;</a>, <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_BrepFace &gt;</a>, and <a class="el" href="class_o_n___object_array.html#a51ee75049ffb91c10f2acb17b99d3a66">ON_ObjectArray&lt; ON_BrepVertex &gt;</a>.</p>

</div>
</div>
<a id="aebeebfb862065c0d62c00389ae3f499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebeebfb862065c0d62c00389ae3f499b">&#9670;&nbsp;</a></span>Insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert called with a reference uses operator =. </p>
<p>Insert copy of element. Uses memmove() to perform any necessary moving. Increases count by 1. </p>
<p>This call to memset is ok even when T has a vtable because in-place construction is used later. <br />
 &lt; uses T::operator=() to copy x to array </p>

</div>
</div>
<a id="ac8ea996fc990ee251d88b324bc8b08f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ea996fc990ee251d88b324bc8b08f2">&#9670;&nbsp;</a></span>KeepArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::KeepArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns pointer to array and zeros out this class. Caller is responsible for calling destructor on each element and then using onfree() to release array memory. E.g.,</p>
<p>for (int i=capacity;i&gt;=0;i&ndash;) { array[i].~T(); } onfree(array); </p>

</div>
</div>
<a id="a5e9dfdb1601fb20ce86dfe8244719665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9dfdb1601fb20ce86dfe8244719665">&#9670;&nbsp;</a></span>Last() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a558bc5d60a7dc8d9885a387e12bd8ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558bc5d60a7dc8d9885a387e12bd8ae6">&#9670;&nbsp;</a></span>Last() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns nullptr if count = 0 </p>

</div>
</div>
<a id="a58673a8f943b627698b7f917b8bbcfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58673a8f943b627698b7f917b8bbcfdf">&#9670;&nbsp;</a></span>Move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Move </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ele_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implimentation ////////////////////////////////////////////////////// </p>
<p>array operations //////////////////////////////////////////////////// </p>
<p>private function for moving blocks of array memory caller is responsible for updating m_count and managing destruction/creation. <br />
 This call to memmove is ok, even when T is a class with a vtable because the it doesn't change the vtable for the class. Classes that have back pointers, like <a class="el" href="class_o_n___user_data.html">ON_UserData</a>, are handled elsewhere and cannot be in ON_ClassArray&lt;&gt;s. </p>

</div>
</div>
<a id="a39b36908b477ca9e79dd435d1802237a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b36908b477ca9e79dd435d1802237a">&#9670;&nbsp;</a></span>NewCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::NewCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is &lt; current <a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8" title="query /////////////////////////////////////////////////////////////// ">Count()</a>, then count is reduced to value. When the dynamic array needs to grow, this calculates the new value for m_capacity. </p>
<p>Note: This code appears in <a class="el" href="class_o_n___simple_array.html#a5d2395da5bc042c230d799ed92c9c564">ON_SimpleArray&lt;T&gt;::NewCapacity()</a> and <a class="el" href="class_o_n___class_array.html#a39b36908b477ca9e79dd435d1802237a">ON_ClassArray&lt;T&gt;::NewCapacity()</a>. Changes made to either function should be made to both functions. Because this code is template code that has to support dynamic linking and the code is defined in a header, I'm using copy-and-paste rather than a static. <br />
<br />
<br />
 This function returns 2*m_count unless that will result in an additional allocation of more than cap_size bytes. The cap_size concept was added in January 2010 because some calculations on enormous models were slightly underestimating the initial <a class="el" href="class_o_n___class_array.html#a619516bde2761154d967c96ee6c2b044" title="memory managment ///////////////////////////////////////////////// ">Reserve()</a> size and then wasting gigabytes of memory. <br />
<br />
 cap_size = 128 MB on 32-bit os, 256 MB on 64 bit os</p>
<p>Growing the array will increase the memory use by more than cap_size. </p>

</div>
</div>
<a id="ad42aed50f4d66e4a33379db171c71fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42aed50f4d66e4a33379db171c71fd8">&#9670;&nbsp;</a></span>operator const T *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator const T * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>to the array. If <a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8" title="query /////////////////////////////////////////////////////////////// ">Count()</a> is zero, this pointer is nullptr. </p>

</div>
</div>
<a id="a5e8b150fdfb6f1c2d5a625ee09273432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8b150fdfb6f1c2d5a625ee09273432">&#9670;&nbsp;</a></span>operator T*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator T* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The cast operators return a pointer. </p>

</div>
</div>
<a id="ab7b741c3481b50b44d69bd4a620296e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b741c3481b50b44d69bd4a620296e8">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt; &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a id="a66e43c5172b763b79df57f2ebc6bc43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e43c5172b763b79df57f2ebc6bc43e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The operator[] does to not check for valid indices. The caller is responsibile for insuring that 0 &lt;= i &lt; <a class="el" href="class_o_n___class_array.html#af828eb3eedaefe303676b81b0b5bd0cd" title="capacity of array ">Capacity()</a> </p>

</div>
</div>
<a id="a38a1f61c17d3a863abe8acc4b053bf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a1f61c17d3a863abe8acc4b053bf9e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcd3c038ace9e6b518f66a87cce6d496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd3c038ace9e6b518f66a87cce6d496">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">ON__INT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a015a992fe8121363317327c107c75c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015a992fe8121363317327c107c75c2d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">ON__UINT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e4d1684feca2845464635d1c43b83a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4d1684feca2845464635d1c43b83a1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5f92b97d51e9aeb89e6c179a0fdd3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f92b97d51e9aeb89e6c179a0fdd3fd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ae5677ba6120233a127eed7c9f564a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae5677ba6120233a127eed7c9f564a1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">ON__INT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac33045d46c4aeaa089909a8eb3f0af3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33045d46c4aeaa089909a8eb3f0af3c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">ON__UINT64&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cd469fb4742e6424f9cabb1c8787c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd469fb4742e6424f9cabb1c8787c2a">&#9670;&nbsp;</a></span>Permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Permute </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permutes the array so that output[i] = input[index[i]]. The index[] array should be a permutation of (0,...,<a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8" title="query /////////////////////////////////////////////////////////////// ">Count()</a>-1). </p>
<p>&lt; must use memcopy and not operator= </p>

</div>
</div>
<a id="aaaccc2915ed9407ed77e5355ed02f61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaccc2915ed9407ed77e5355ed02f61a">&#9670;&nbsp;</a></span>QuickSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::QuickSort </td>
          <td>(</td>
          <td class="paramtype">int(*)(const T *, const T *)&#160;</td>
          <td class="paramname"><em>compar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the array using the heap sort algorithm. </p>

<p>Reimplemented in <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; T &gt;</a>, <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_Texture &gt;</a>, <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_BrepTrim &gt;</a>, <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_BrepFaceSide &gt;</a>, <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_BrepEdge &gt;</a>, <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_BrepLoop &gt;</a>, <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_BrepRegion &gt;</a>, <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_BrepFace &gt;</a>, and <a class="el" href="class_o_n___object_array.html#a53ef05dd586f31c2ddb4980185153398">ON_ObjectArray&lt; ON_BrepVertex &gt;</a>.</p>

</div>
</div>
<a id="a6146b9447dfc2420fd1ddc79f4e25d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6146b9447dfc2420fd1ddc79f4e25d13">&#9670;&nbsp;</a></span>Realloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Realloc </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>low level memory managment /////////////////////////////////////// </p>
<p>Class ON_ClassArray&lt;&gt;</p>
<p>By default, ON_ClassArray&lt;&gt; uses onrealloc() to manage the dynamic array memory. If you want to use something besides onrealloc() to manage the array memory, then override <a class="el" href="class_o_n___class_array.html#a6146b9447dfc2420fd1ddc79f4e25d13" title="low level memory managment /////////////////////////////////////// ">Realloc()</a>. The T* Realloc(ptr, capacity) should do the following:</p>
<p>1) If ptr and capacity are zero, return nullptr. 2) If ptr is nullptr, an capacity &gt; 0, allocate a memory block of capacity*sizeof(T) bytes and return a pointer to this block. If the allocation request fails, return nullptr. 3) If ptr is not nullptr and capacity is 0, free the memory block pointed to by ptr and return nullptr. 4) If ptr is not nullptr and capacity &gt; 0, then reallocate the memory block and return a pointer to the reallocated block. If the reallocation request fails, return nullptr.</p>
<p>NOTE WELL: Microsoft's VC 6.0 realloc() contains a bug that can cause crashes and should be avoided. See MSDN Knowledge Base article ID Q225099 for more information. (re)allocated capacity*sizeof(T) bytes</p>
<p>construction //////////////////////////////////////////////////////// </p>

<p>Reimplemented in <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; T &gt;</a>, <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_Texture &gt;</a>, <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_BrepTrim &gt;</a>, <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_BrepFaceSide &gt;</a>, <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_BrepEdge &gt;</a>, <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_BrepLoop &gt;</a>, <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_BrepRegion &gt;</a>, <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_BrepFace &gt;</a>, and <a class="el" href="class_o_n___object_array.html#a13c0a45951d15ca0d2a522e553b4a842">ON_ObjectArray&lt; ON_BrepVertex &gt;</a>.</p>

</div>
</div>
<a id="ac8613b7ab26dfabe4d630052a7167445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8613b7ab26dfabe4d630052a7167445">&#9670;&nbsp;</a></span>Remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes last element. Decrements count by 1. Does not change capacity. </p>

</div>
</div>
<a id="a91061614b1ec05b07b891579e83ed9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91061614b1ec05b07b891579e83ed9a8">&#9670;&nbsp;</a></span>Remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes element. Uses memmove() to perform any necessary shifting. Decrements count by 1. Does not change capacity </p>
<p>This call to memset is ok even when T has a vtable because in-place construction is used later. <br />
 This call to memset is ok even when T has a vtable because in-place construction is used later. </p>

</div>
</div>
<a id="a619516bde2761154d967c96ee6c2b044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619516bde2761154d967c96ee6c2b044">&#9670;&nbsp;</a></span>Reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newcap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory managment ///////////////////////////////////////////////// </p>
<p>memory managment ////////////////////////////////////////////////////</p>
<p>increase capacity to at least the requested value </p>

</div>
</div>
<a id="ae0cf9e8ff629067820b78bf8fa4723fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cf9e8ff629067820b78bf8fa4723fd">&#9670;&nbsp;</a></span>Reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverse order </p>
<p>NOTE: If anything in "T" depends on the value of this's address, then don't call <a class="el" href="class_o_n___class_array.html#ae0cf9e8ff629067820b78bf8fa4723fd" title="reverse order ">Reverse()</a>. </p>

</div>
</div>
<a id="a815f500f614c1742ba1f250b6e46ab1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815f500f614c1742ba1f250b6e46ab1c">&#9670;&nbsp;</a></span>Search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Search </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const T *, const T *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search( p, compare ) does a SLOW search of the array starting at array[0] and returns the index "i" of the first element that satisfies compare(p,&amp;array[i])==0. If the search is not successful, then <a class="el" href="class_o_n___class_array.html#a815f500f614c1742ba1f250b6e46ab1c">Search()</a> returns -1. <a class="el" href="class_o_n___class_array.html#a815f500f614c1742ba1f250b6e46ab1c">Search()</a> is only suitable for performing infrequent searches of small arrays. Sort the array and use <a class="el" href="class_o_n___class_array.html#a6f69264bb06391c81571f0182fbaef08" title="See Also: ON_CompareIncreasing&lt;T&gt; and ON_CompareDeccreasing&lt;T&gt; ">BinarySearch()</a> for performing efficient searches. </p>

</div>
</div>
<a id="a404695bf0683f18b0e2a1b2cc2538fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404695bf0683f18b0e2a1b2cc2538fa3">&#9670;&nbsp;</a></span>SetArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::SetArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Do not use this version of <a class="el" href="class_o_n___class_array.html#a404695bf0683f18b0e2a1b2cc2538fa3">SetArray()</a>. Use the one that takes a pointer, count and capacity: SetArray(pointer,count,capacity) </p>

</div>
</div>
<a id="a382c44cb8eaa73cc598d587fdfda5220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382c44cb8eaa73cc598d587fdfda5220">&#9670;&nbsp;</a></span>SetArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::SetArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to set the memory used by the dyanmic array. Parameters: T* pointer - [in] int count - [in] 0 &lt;= count &lt;= capacity int capacity - [in] m_a is set to pointer, m_count is set to count, and m_capacity is set to capacity. It is critical that the pointer be one returned by onmalloc(sz), where sz &gt;= capacity*sizeof(T[0]), and that the in-place operator new has been used to initialize each element of the array. </p>

</div>
</div>
<a id="a49bc44bb095af6dd8173a91441b78bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bc44bb095af6dd8173a91441b78bfd">&#9670;&nbsp;</a></span>SetCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::SetCapacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrink/grows capacity. If value </p>
<p>Allow "expert" users of ON_SimpleArray&lt;&gt;.SetArray(*,*,0) to clean up after themselves and deals with the case when the forget to clean up after themselves. <br />
<br />
<br />
<br />
<br />
<br />
<br />
 uses "placement" for class construction/destruction</p>
<p>growing</p>
<p>initialize new elements with default constructor</p>
<p>even when m_a is an array of classes with vtable pointers, this call to memset(..., 0, ...) is what I want to do because in-place construction will be used when needed on this memory. <br />
<br />
<br />
 memory allocation failed</p>
<p>shrinking</p>
<p>memory allocation failed </p>

</div>
</div>
<a id="a7ffd376de3d1af10f22caea8e5b5d114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffd376de3d1af10f22caea8e5b5d114">&#9670;&nbsp;</a></span>SetCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::SetCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low level memory managment ////////////////////////////////////////// </p>
<p>If value is &lt;= <a class="el" href="class_o_n___class_array.html#af828eb3eedaefe303676b81b0b5bd0cd" title="capacity of array ">Capacity()</a>, then sets count to specified value. </p>

</div>
</div>
<a id="a34c5ba8cd96d26d1880e2ecd0f21b6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c5ba8cd96d26d1880e2ecd0f21b6e5">&#9670;&nbsp;</a></span>Shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Shrink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove unused capacity </p>

</div>
</div>
<a id="a317aa7fa09844d153876fa707ae87e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317aa7fa09844d153876fa707ae87e2d">&#9670;&nbsp;</a></span>SizeOfArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::SizeOfArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>amount of memory in the m_a[] array </p>

</div>
</div>
<a id="adf0b64e2722e1e77fa1dfd5fe1e222de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0b64e2722e1e77fa1dfd5fe1e222de">&#9670;&nbsp;</a></span>SizeOfElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::SizeOfElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>amount of memory in an m_a[] array element </p>

</div>
</div>
<a id="acc32ae1ba071b666ae49a9d2c2a041e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc32ae1ba071b666ae49a9d2c2a041e7">&#9670;&nbsp;</a></span>Sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype">ON::sort_algorithm&#160;</td>
          <td class="paramname"><em>sort_algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const T *, const T *)&#160;</td>
          <td class="paramname"><em>compar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: <a class="el" href="class_o_n___class_array.html#acc32ae1ba071b666ae49a9d2c2a041e7">Sort()</a> fills in the index[] array so that array[index[i]] &lt;= array[index[i+1]]. <br />
 The array is not modified. <br />
 Parameters: sort_algorithm - [in] <br />
 ON::sort_algorithm::quick_sort (best in general) or ON::sort_algorithm::heap_sort Use ON::sort_algorithm::heap_sort only if you have done extensive testing with optimized release builds and are confident heap sort is significantly faster. index - [out] an array of length <a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8" title="query /////////////////////////////////////////////////////////////// ">Count()</a> that is returned with some permutation of (0,1,...,<a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8" title="query /////////////////////////////////////////////////////////////// ">Count()</a>-1). compare - [in] compare function compare(a,b) should return &lt;0 if a&lt;b, 0, if a==b, and &gt;0 if a&gt;b.</p>
<p>Returns: true if successful </p>

</div>
</div>
<a id="a62165890958430bf2e377aaabc7fd93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62165890958430bf2e377aaabc7fd93c">&#9670;&nbsp;</a></span>Sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype">ON::sort_algorithm&#160;</td>
          <td class="paramname"><em>sort_algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const T *, const T *, void *)&#160;</td>
          <td class="paramname"><em>compar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: <a class="el" href="class_o_n___class_array.html#acc32ae1ba071b666ae49a9d2c2a041e7">Sort()</a> fills in the index[] array so that array[index[i]] &lt;= array[index[i+1]]. <br />
 The array is not modified. <br />
 Parameters: sort_algorithm - [in] <br />
 ON::sort_algorithm::quick_sort (best in general) or ON::sort_algorithm::heap_sort Use ON::sort_algorithm::heap_sort only if you have done extensive testing with optimized release builds and are confident heap sort is significantly faster. index - [out] an array of length <a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8" title="query /////////////////////////////////////////////////////////////// ">Count()</a> that is returned with some permutation of (0,1,...,<a class="el" href="class_o_n___class_array.html#a1845abffe10408c4ce46046d9232f8e8" title="query /////////////////////////////////////////////////////////////// ">Count()</a>-1). compare - [in] compare function compare(a,b,p) should return &lt;0 if a&lt;b, 0, if a==b, and &gt;0 if a&gt;b. p - [in] pointer passed as third argument to compare.</p>
<p>Returns: true if successful </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index[] </td></tr>
    <tr><td class="paramname">compar</td><td>int compare(const T*,const T*,void* p) </td></tr>
    <tr><td class="paramname">p</td><td>p </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa00c91a632d42ebbd4a04715750953ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00c91a632d42ebbd4a04715750953ca">&#9670;&nbsp;</a></span>Swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Swap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swap elements i and j </p>

</div>
</div>
<a id="a64d1db4495becbc776ba36549ad93fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d1db4495becbc776ba36549ad93fd1">&#9670;&nbsp;</a></span>UnsignedCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::UnsignedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e749c63bb84c2b09ade86283f6d7707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e749c63bb84c2b09ade86283f6d7707">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all elements and fills them with values set by the defualt constructor. Count and capacity are not changed. </p>
<p>This call to memset is ok even when T has a vtable because in-place construction is used later. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="adfced275ab81f79ae6a60d5f660c0fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfced275ab81f79ae6a60d5f660c0fdf">&#9670;&nbsp;</a></span>m_a</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::m_a</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to array memory </p>

</div>
</div>
<a id="a867ba84ffce9dc8146dc5e7ce71d9ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867ba84ffce9dc8146dc5e7ce71d9ac8">&#9670;&nbsp;</a></span>m_capacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::m_capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>actual length of m_a[] </p>

</div>
</div>
<a id="af361d7cf1705dccf62a534ddd0c48a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af361d7cf1705dccf62a534ddd0c48a69">&#9670;&nbsp;</a></span>m_count</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; T &gt;::m_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0 &lt;= m_count &lt;= m_capacity </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 25 2018 17:01:10 for openNURBS SDK Help by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
