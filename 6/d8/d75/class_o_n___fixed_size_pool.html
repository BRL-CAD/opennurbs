<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=9"/>
  <meta name="generator" content="Doxygen 1.8.13"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>openNURBS SDK Help: ON_FixedSizePool Class Reference</title>
  <link href="../../tabs.css" rel="stylesheet" type="text/css"/>
  <!-- <script type="text/javascript" src="../../jquery.js"></script> -->
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script type="text/javascript" src="../../dynsections.js"></script>
  <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
  <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
  <!-- bootstrap -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <!-- smartmenus -->
  <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
  <script type="text/javascript" src="../../jquery.smartmenus.js"></script>
  <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.js"></script>
</head>
<body>
  <!-- <div class="version-banner">
    Go back to the <a href="/">main site</a>...
  </div> -->
  <div class="container">
    <!-- navbar -->
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">openNURBS SDK Help</a>
        <div class="navbar-collapse collapse" id="main-nav-placeholder">
          <!-- <p class="navbar-text navbar-right">v6.0</p> -->
          <ul class="nav navbar-nav navbar-right">
            <li class="dropdown">
              <a class="dropdown-toggle" href="#">v6.0 <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="#">Latest (6.x)</a></li>
                <li class="disabled"><a href="#">WIP (7.x)</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="page-content">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d5/d36/class_o_n___fixed_size_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_FixedSizePool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d5/d00/opennurbs__fsp_8h_source.html">opennurbs_fsp.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_FixedSizePool:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d8/d75/class_o_n___fixed_size_pool.png" usemap="#ON_5FFixedSizePool_map" alt=""/>
  <map id="ON_5FFixedSizePool_map" name="ON_5FFixedSizePool_map">
<area href="../../db/d36/class_o_n___internal___font_glyph_pool.html" alt="ON_Internal_FontGlyphPool" shape="rect" coords="0,56,186,80"/>
<area href="../../d0/d41/class_o_n___simple_fixed_size_pool.html" alt="ON_SimpleFixedSizePool&lt; T &gt;" shape="rect" coords="196,56,382,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad17cc7144c361db18aef3f55f0e19635"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#ad17cc7144c361db18aef3f55f0e19635">ON_FixedSizePool</a> ()</td></tr>
<tr class="separator:ad17cc7144c361db18aef3f55f0e19635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c014d7b1389567913271d943fbd0b40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a8c014d7b1389567913271d943fbd0b40">~ON_FixedSizePool</a> ()</td></tr>
<tr class="separator:a8c014d7b1389567913271d943fbd0b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72118f85b7cf24b221263e1ad3fd8b8b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a72118f85b7cf24b221263e1ad3fd8b8b">ActiveElementCount</a> () const</td></tr>
<tr class="separator:a72118f85b7cf24b221263e1ad3fd8b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e19b6da55db8fe63a3e526c901bba9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a57e19b6da55db8fe63a3e526c901bba9">AllocateDirtyElement</a> ()</td></tr>
<tr class="separator:a57e19b6da55db8fe63a3e526c901bba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500f50edb2b7efff4655f4ea9c264fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement</a> ()</td></tr>
<tr class="separator:a500f50edb2b7efff4655f4ea9c264fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0904463b277ba449081d8b2929c8ef26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26">Create</a> (size_t sizeof_element, size_t element_count_estimate, size_t block_element_capacity)</td></tr>
<tr class="memdesc:a0904463b277ba449081d8b2929c8ef26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fixed size memory pool.  <a href="#a0904463b277ba449081d8b2929c8ef26">More...</a><br /></td></tr>
<tr class="separator:a0904463b277ba449081d8b2929c8ef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373f8bb4eda7fe5abfb08875a87ac00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a373f8bb4eda7fe5abfb08875a87ac00a">Destroy</a> ()</td></tr>
<tr class="memdesc:a373f8bb4eda7fe5abfb08875a87ac00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the pool and free all the heap. The pool cannot be used again until <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26" title="Create a fixed size memory pool. ">Create()</a> is called.  <a href="#a373f8bb4eda7fe5abfb08875a87ac00a">More...</a><br /></td></tr>
<tr class="separator:a373f8bb4eda7fe5abfb08875a87ac00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23bc8f7379187a60621be143ba59c61"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#ab23bc8f7379187a60621be143ba59c61">Element</a> (size_t element_index) const</td></tr>
<tr class="memdesc:ab23bc8f7379187a60621be143ba59c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th elment in the fixed size pool.  <a href="#ab23bc8f7379187a60621be143ba59c61">More...</a><br /></td></tr>
<tr class="separator:ab23bc8f7379187a60621be143ba59c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deb1bdc66640e2a95b19f51af9bed49"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a9deb1bdc66640e2a95b19f51af9bed49">ElementFromId</a> (size_t id_offset, unsigned int id) const</td></tr>
<tr class="memdesc:a9deb1bdc66640e2a95b19f51af9bed49"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you are certain that all elements in hte pool (active and returned) have an unsigned id that is unique and increasing, then you may use this function to find them.  <a href="#a9deb1bdc66640e2a95b19f51af9bed49">More...</a><br /></td></tr>
<tr class="separator:a9deb1bdc66640e2a95b19f51af9bed49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d7012aaeddd359d200ae9fcee404c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a37d7012aaeddd359d200ae9fcee404c8">ElementIndex</a> (const void *element_pointer) const</td></tr>
<tr class="memdesc:a37d7012aaeddd359d200ae9fcee404c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fixed size pool index of an element.  <a href="#a37d7012aaeddd359d200ae9fcee404c8">More...</a><br /></td></tr>
<tr class="separator:a37d7012aaeddd359d200ae9fcee404c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84143b885fb1b9afe66b8012d6746b66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a84143b885fb1b9afe66b8012d6746b66">IsValid</a> () const</td></tr>
<tr class="memdesc:a84143b885fb1b9afe66b8012d6746b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primarily used for debugging.  <a href="#a84143b885fb1b9afe66b8012d6746b66">More...</a><br /></td></tr>
<tr class="separator:a84143b885fb1b9afe66b8012d6746b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b965fdd3105a9c6d05cce330634c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a96b965fdd3105a9c6d05cce330634c84">ReturnAll</a> ()</td></tr>
<tr class="memdesc:a96b965fdd3105a9c6d05cce330634c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all allocated elements to the pool. No heap is freed and the pool remains initialized and ready for <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> to be called.  <a href="#a96b965fdd3105a9c6d05cce330634c84">More...</a><br /></td></tr>
<tr class="separator:a96b965fdd3105a9c6d05cce330634c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5cb208942ebb038e9cce4bfdadbbc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement</a> (void *p)</td></tr>
<tr class="memdesc:a3b5cb208942ebb038e9cce4bfdadbbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an element to the pool.  <a href="#a3b5cb208942ebb038e9cce4bfdadbbc3">More...</a><br /></td></tr>
<tr class="separator:a3b5cb208942ebb038e9cce4bfdadbbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a3eca1cfbd2272826d1a69610fdd77"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement</a> () const</td></tr>
<tr class="separator:a08a3eca1cfbd2272826d1a69610fdd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a9799631f05f0ec3b239ba44934335"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#aa9a9799631f05f0ec3b239ba44934335">TotalElementCount</a> () const</td></tr>
<tr class="separator:aa9a9799631f05f0ec3b239ba44934335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6b3a440f8ac861a8d7731be18603eb84"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a6b3a440f8ac861a8d7731be18603eb84">ON_FixedSizePoolIterator</a></td></tr>
<tr class="separator:a6b3a440f8ac861a8d7731be18603eb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad17cc7144c361db18aef3f55f0e19635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17cc7144c361db18aef3f55f0e19635">&#9670;&nbsp;</a></span>ON_FixedSizePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_FixedSizePool::ON_FixedSizePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c014d7b1389567913271d943fbd0b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c014d7b1389567913271d943fbd0b40">&#9670;&nbsp;</a></span>~ON_FixedSizePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_FixedSizePool::~ON_FixedSizePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a72118f85b7cf24b221263e1ad3fd8b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72118f85b7cf24b221263e1ad3fd8b8b">&#9670;&nbsp;</a></span>ActiveElementCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::ActiveElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of active elements. (Elements that have been returned are not active.) </dd></dl>

</div>
</div>
<a id="a57e19b6da55db8fe63a3e526c901bba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e19b6da55db8fe63a3e526c901bba9">&#9670;&nbsp;</a></span>AllocateDirtyElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::AllocateDirtyElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to sizeof_element bytes. The values in the returned block are undefined. </dd></dl>

</div>
</div>
<a id="a500f50edb2b7efff4655f4ea9c264fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500f50edb2b7efff4655f4ea9c264fa2">&#9670;&nbsp;</a></span>AllocateElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::AllocateElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to sizeof_element bytes. The memory is zeroed. </dd></dl>

</div>
</div>
<a id="a0904463b277ba449081d8b2929c8ef26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0904463b277ba449081d8b2929c8ef26">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_FixedSizePool::Create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeof_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_count_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_element_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fixed size memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeof_element</td><td>[in] number of bytes in each element. This parameter must be greater than zero. In general, use sizeof(element type). If you pass a "raw" number as sizeof_element, then be certain that it is the right size to insure the fields in your elements will be properly aligned.</td></tr>
    <tr><td class="paramname">element_count_estimate</td><td>[in] (0 = good default) If you know how many elements you will need, pass that number here. It is better to slightly overestimate than to slightly underestimate. If you do not have a good estimate, then use zero.</td></tr>
    <tr><td class="paramname">block_element_capacity</td><td>[in] (0 = good default) If block_element_capacity is zero, <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26" title="Create a fixed size memory pool. ">Create()</a> will calculate a block size that is efficent for most applications. If you are an expert user and want to specify the number of elements per block, then pass the number of elements per block here. When block_element_capacity &gt; 0 and element_count_estimate &gt; 0, the first block will have a capacity of at least element_count_estimate; in this case do not ask for extraordinarly large amounts of contiguous heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful and the pool can be used. </dd></dl>
<p>You must call <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26" title="Create a fixed size memory pool. ">Create()</a> on an unused <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> or call <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a373f8bb4eda7fe5abfb08875a87ac00a" title="Destroy the pool and free all the heap. The pool cannot be used again until Create() is called...">Destroy()</a> before calling create. </p>

</div>
</div>
<a id="a373f8bb4eda7fe5abfb08875a87ac00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373f8bb4eda7fe5abfb08875a87ac00a">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePool::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the pool and free all the heap. The pool cannot be used again until <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26" title="Create a fixed size memory pool. ">Create()</a> is called. </p>

</div>
</div>
<a id="ab23bc8f7379187a60621be143ba59c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23bc8f7379187a60621be143ba59c61">&#9670;&nbsp;</a></span>Element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::Element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the i-th elment in the fixed size pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_index</td><td>[in]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the element with the specified index. The first element has element_index = 0 and is the element returned by the first call to <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a>. The last element has element_index = ElementCount()-1. If element_index is out of range, nullptr is returned. </dd></dl>
<p>It is faster to use <a class="el" href="../../de/da1/class_o_n___fixed_size_pool_iterator.html#a0d52d7d6fc5290d8a9266bab85d3b88c" title="Get the first element when iterating through the list of elements. ">ON_FixedSizePoolIterator.FirstElement()</a> and <a class="el" href="../../de/da1/class_o_n___fixed_size_pool_iterator.html#a502e802f6f5dd70c8f868dffd3111fcc" title="Get the next element when iterating through the list of elements. If FirstElement() is not called...">ON_FixedSizePoolIterator.NextElement()</a> to iterate through the entire list of elements. This function is relatively efficient when there are a few large blocks in the pool or element_index is small compared to the number of elements in the first few blocks.</p>
<p>If <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a> is not used or no <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> calls are made after any use of <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a>, then the i-th element is the one returned by the (i+1)-th call to <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> </p>

</div>
</div>
<a id="a9deb1bdc66640e2a95b19f51af9bed49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deb1bdc66640e2a95b19f51af9bed49">&#9670;&nbsp;</a></span>ElementFromId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::ElementFromId </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you are certain that all elements in hte pool (active and returned) have an unsigned id that is unique and increasing, then you may use this function to find them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_offset</td><td>[in] offset into the element where the id is stored.</td></tr>
    <tr><td class="paramname">id</td><td>[in] id to search for</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d7012aaeddd359d200ae9fcee404c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d7012aaeddd359d200ae9fcee404c8">&#9670;&nbsp;</a></span>ElementIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::ElementIndex </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>element_pointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fixed size pool index of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_pointer</td><td>[in]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An index &gt;= 0 and &lt; ON_MAX_SIZE_T if the element_pointer points to an element managed by the this fixed size pool. ON_MAX_SIZE_T otherwise. </dd></dl>
<p>It is faster to use <a class="el" href="../../de/da1/class_o_n___fixed_size_pool_iterator.html#a0d52d7d6fc5290d8a9266bab85d3b88c" title="Get the first element when iterating through the list of elements. ">ON_FixedSizePoolIterator.FirstElement()</a> and <a class="el" href="../../de/da1/class_o_n___fixed_size_pool_iterator.html#a502e802f6f5dd70c8f868dffd3111fcc" title="Get the next element when iterating through the list of elements. If FirstElement() is not called...">ON_FixedSizePoolIterator.NextElement()</a> to iterate through the entire list of elements. This function is relatively efficient when there are a few large blocks in the pool or element_pointer is an element in the first few blocks.</p>
<p>If <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a> is not used or no <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> calls are made after any use of <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a>, then the i-th element is the one returned by the (i+1)-th call to <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a>. </p>

</div>
</div>
<a id="a84143b885fb1b9afe66b8012d6746b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84143b885fb1b9afe66b8012d6746b66">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_FixedSizePool::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Primarily used for debugging. </p>

</div>
</div>
<a id="a96b965fdd3105a9c6d05cce330634c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b965fdd3105a9c6d05cce330634c84">&#9670;&nbsp;</a></span>ReturnAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePool::ReturnAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all allocated elements to the pool. No heap is freed and the pool remains initialized and ready for <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> to be called. </p>

</div>
</div>
<a id="a3b5cb208942ebb038e9cce4bfdadbbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5cb208942ebb038e9cce4bfdadbbc3">&#9670;&nbsp;</a></span>ReturnElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePool::ReturnElement </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an element to the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>[in] A pointer returned by <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a>. It is critical that p be from this pool and that you return a pointer no more than one time.</td></tr>
  </table>
  </dd>
</dl>
<p>If you find the following remarks confusing, but you really want to use <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a>, then here are some simple guidelines. 1) <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be &gt;= 16 2) <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be a multiple of 8. 3) Do not use FirstElement() and NextElement() to iterate through the pool.</p>
<p>If 1 to 3 don't work for you, then you need to understand the following information before using <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a>.</p>
<p>ON_FixedMemoryPool uses the first sizeof(void*) bytes of the returned element for bookkeeping purposes. Therefore, if you are going to use <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a>, then <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be at least sizeof(void*). If you are using a platform that requires pointers to be aligned on sizeof(void*) boundaries, then <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be a multiple of sizeof(void*). If you are going to use <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a> and then use FirstElement() and NextElement() to iterate through the list of elements, then you need to set a value in the returned element to indicate that it needs to be skipped during the iteration. This value cannot be located in the fist sizeof(void*) bytes of the element. If the element is a class with a vtable, you cannot call a virtual function on a returned element because the vtable pointer is trashed when <a class="el" href="../../d8/d75/class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3" title="Return an element to the pool. ">ReturnElement()</a> modifies the fist sizeof(void*) bytes. </p>

</div>
</div>
<a id="a08a3eca1cfbd2272826d1a69610fdd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a3eca1cfbd2272826d1a69610fdd77">&#9670;&nbsp;</a></span>SizeofElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::SizeofElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Size of the elements in this pool. </dd></dl>

</div>
</div>
<a id="aa9a9799631f05f0ec3b239ba44934335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a9799631f05f0ec3b239ba44934335">&#9670;&nbsp;</a></span>TotalElementCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::TotalElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Total number of elements = number of active elements + number of returned elements. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6b3a440f8ac861a8d7731be18603eb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3a440f8ac861a8d7731be18603eb84">&#9670;&nbsp;</a></span>ON_FixedSizePoolIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../de/da1/class_o_n___fixed_size_pool_iterator.html">ON_FixedSizePoolIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
    </div> <!-- page-content -->
    <hr class="footer"/><address class="footer"><small>
    Generated on Sat Feb 3 2018 11:08:30 for openNURBS SDK Help by <a href="http://www.doxygen.org/index.html">
    <!-- <img class="footer" src="../../doxygen.png" alt="doxygen"/> -->
    Doxygen
    </a> 1.8.13
    </small></address>
  </div> <!-- container -->
  <!-- doxy-boot -->
  <script type="text/javascript" src="../../doxy-boot.js"></script>
</body>
</html>
